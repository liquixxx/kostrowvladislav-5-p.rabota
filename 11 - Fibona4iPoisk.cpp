//ISTO4KIN: https://ru.stackoverflow.com/questions/1047768/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BC-%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D0%B8-%D0%BD%D0%B0-%D1%81

#include <iostream>
#include <algorithm>  // для функции sort()
#include <locale>     // для setlocale()
using namespace std;

// Рекурсивная функция вычисления чисел Фибоначчи
// Сложность: O(2^n) - очень медленная из-за повторных вычислений
long int Fib(int i)
{
    int value = 0;  // Эта переменная не используется, можно удалить
    
    // Базовые случаи рекурсии
    if (i < 1) return 0;   // F(0) = 0
    if (i == 1) return 1;  // F(1) = 1
    
    // Рекурсивный вызов: F(n) = F(n-1) + F(n-2)
    return Fib(i - 1) + Fib(i - 2);
}

int main()
{
    setlocale(0, "rus");  // Устанавливаем русскую локаль для корректного отображения текста

    int N;
    cout << "Введите размер массива: " << endl;
    cin >> N;  // Получаем размер массива от пользователя

    // Динамически выделяем память для массива
    int* arr = new int[N];
    int key;  // Переменная для хранения искомого значения

    cout << "Заполните массив целыми числами: " << endl;

    // Заполняем массив значениями от пользователя
    for (int i = 0; i != N; i++)
    {
        cin >> arr[i];
    }

    // Сортируем массив по возрастанию (обязательное условие для поиска)
    sort(arr, arr + N);

    cout << endl << "Введите ключ: ";
    cin >> key;  // Получаем значение для поиска

    // Переменные для алгоритма поиска
    bool flag = false;  // Флаг найден ли элемент
    int l = 0;          // Левая граница поиска (не используется в текущей реализации)
    int r = N;          // Правая граница поиска (не используется корректно)
    int i = 0;          // Индекс для чисел Фибоначчи
    
    // Пытаемся выполнить поиск (алгоритм неполный и содержит ошибки)
    while ((l <= r) && (flag != true)) {
        // Проверяем элемент на позиции Fib(i)
        if (arr[Fib(i)] == key) flag = true;  // Если нашли элемент
        
        // Если текущий элемент больше искомого
        if (arr[Fib(i)] > key) r = Fib(i);    // Сдвигаем правую границу
        
        // ОШИБКА: отсутствует увеличение i, что приводит к бесконечному циклу
        // Нет случая когда arr[Fib(i)] < key
        // Нет обновления левой границы l
    }

    // Выводим результат поиска
    if (flag) 
        cout << "Индекс элемента " << key << " в массиве равен: " << Fib(i);
    else 
        cout << "Извините, но такого элемента в массиве нет";

    // Очищаем память (важно для избежания утечек)
    delete[] arr;
    
    system("pause");  // Ожидаем нажатия клавиши перед завершением
    return 0;
}
